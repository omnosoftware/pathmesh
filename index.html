<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>PathMesh</title>

<style>
* { margin:0; padding:0; box-sizing:border-box; }
html,body { width:100%; height:100%; overflow:hidden; font-family:sans-serif; }

canvas { display:block; }

.overlay {
  position:fixed;
  bottom:20px;
  left:50%;
  transform:translateX(-50%);
  width:90%;
  max-width:400px;
  display:flex;
  flex-direction:column;
  gap:10px;
  z-index:10;
}

.status {
  text-align:center;
  color:white;
  font-size:14px;
}

button {
  padding:14px;
  border:none;
  border-radius:12px;
  background:#f97316;
  color:white;
  font-size:16px;
  font-weight:bold;
}

#compass {
  position:fixed;
  top:20px;
  left:20px;
  width:80px;
  height:80px;
  border-radius:50%;
  background:white;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:bold;
  z-index:10;
}

#minimap {
  position:fixed;
  top:20px;
  right:20px;
  width:120px;
  height:120px;
  background:rgba(255,255,255,0.8);
  border-radius:12px;
  z-index:10;
}
</style>
</head>

<body>

<div id="compass">N</div>
<canvas id="minimap"></canvas>

<div class="overlay">
  <div class="status" id="status">Aguardando GPS...</div>
  <button id="finishBtn">Finalizar Caminhada</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
let scene, camera, renderer;
let player, trail;
let pathPoints = [];
let origin = null;
let heading = 0;
let statusEl = document.getElementById("status");

init();
animate();
startGPS();
initCompass();

function init() {
  scene = new THREE.Scene();

  // ðŸŒ¤ CÃ©u gradiente
  const skyGeo = new THREE.SphereGeometry(5000, 32, 32);
  const skyMat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
      topColor: { value: new THREE.Color(0x87ceeb) },
      bottomColor: { value: new THREE.Color(0xffffff) }
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      varying vec3 vWorldPosition;
      void main() {
        float h = normalize(vWorldPosition).y;
        gl_FragColor = vec4(mix(bottomColor, topColor, max(h,0.0)), 1.0);
      }
    `
  });
  scene.add(new THREE.Mesh(skyGeo, skyMat));

  camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 10000);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff,0.7));
  const sun = new THREE.DirectionalLight(0xffffff,1);
  sun.position.set(300,400,200);
  scene.add(sun);

  // ðŸŒ± chÃ£o
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(4000,4000),
    new THREE.MeshStandardMaterial({ color:0x3da13d })
  );
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // ðŸ‘¤ player
  player = new THREE.Mesh(
    new THREE.SphereGeometry(4,16,16),
    new THREE.MeshStandardMaterial({ color:0xff0000 })
  );
  player.position.y = 4;
  scene.add(player);

  // ðŸŒ³ Ã¡rvores
  for(let i=0;i<50;i++){
    createTree((Math.random()-0.5)*3000,(Math.random()-0.5)*3000);
  }

  // ðŸŒ„ montanhas
  for(let i=0;i<20;i++){
    createMountain((Math.random()-0.5)*3500,(Math.random()-0.5)*3500);
  }

  window.addEventListener("resize",()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });
}

function createTree(x,z){
  const trunk = new THREE.Mesh(
    new THREE.CylinderGeometry(2,2,20),
    new THREE.MeshStandardMaterial({ color:0x8b5a2b })
  );
  trunk.position.set(x,10,z);
  scene.add(trunk);

  const leaves = new THREE.Mesh(
    new THREE.ConeGeometry(10,30,8),
    new THREE.MeshStandardMaterial({ color:0x1f7a1f })
  );
  leaves.position.set(x,30,z);
  scene.add(leaves);
}

function createMountain(x,z){
  const mountain = new THREE.Mesh(
    new THREE.ConeGeometry(80,200,4),
    new THREE.MeshStandardMaterial({ color:0x888888 })
  );
  mountain.position.set(x,100,z);
  scene.add(mountain);
}

function startGPS(){
  if(!navigator.geolocation){
    statusEl.innerText="GPS nÃ£o suportado";
    return;
  }

  navigator.geolocation.watchPosition(pos=>{
    const lat=pos.coords.latitude;
    const lng=pos.coords.longitude;

    if(!origin){
      origin={lat,lng};
      statusEl.innerText="GPS conectado";
    }

    const scale=111139;
    const x=(lng-origin.lng)*scale;
    const z=(lat-origin.lat)*scale;

    updatePlayer(x,z);
  },()=>statusEl.innerText="Erro GPS",{enableHighAccuracy:true});
}

function updatePlayer(x,z){
  const newPos=new THREE.Vector3(x,4,z);
  if(pathPoints.length>0 && pathPoints[pathPoints.length-1].distanceTo(newPos)<1) return;

  player.position.copy(newPos);
  pathPoints.push(newPos.clone());
  updateTrail();
}

function updateTrail(){
  if(trail) scene.remove(trail);
  trail = new THREE.Line(
    new THREE.BufferGeometry().setFromPoints(pathPoints),
    new THREE.LineBasicMaterial({ color:0xf97316 })
  );
  scene.add(trail);
}

function animate(){
  requestAnimationFrame(animate);

  // ðŸŽ¥ cÃ¢mera suave atrÃ¡s do player
  const offset = new THREE.Vector3(
    Math.sin(heading*Math.PI/180)*120,
    80,
    Math.cos(heading*Math.PI/180)*120
  );

  const desiredPos = player.position.clone().add(offset);
  camera.position.lerp(desiredPos,0.05);
  camera.lookAt(player.position);

  renderer.render(scene,camera);
  updateMiniMap();
}

function initCompass(){
  if (typeof DeviceOrientationEvent !== 'undefined') {
    window.addEventListener("deviceorientation",(e)=>{
      heading = e.alpha || 0;
      document.getElementById("compass").style.transform =
        "rotate("+(-heading)+"deg)";
    });
  }
}

function updateMiniMap(){
  const canvas=document.getElementById("minimap");
  const ctx=canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle="green";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.strokeStyle="orange";
  ctx.beginPath();
  pathPoints.forEach((p,i)=>{
    const mx = canvas.width/2 + p.x*0.02;
    const mz = canvas.height/2 + p.z*0.02;
    if(i===0) ctx.moveTo(mx,mz);
    else ctx.lineTo(mx,mz);
  });
  ctx.stroke();

  ctx.fillStyle="red";
  ctx.beginPath();
  ctx.arc(canvas.width/2,canvas.height/2,4,0,Math.PI*2);
  ctx.fill();
}
</script>

</body>
</html>