<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>PathMesh</title>

<style>
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: sans-serif;
    background: #000;
}

#status {
    position: absolute;
    bottom: 90px;
    width: 100%;
    text-align: center;
    color: white;
    font-size: 18px;
    z-index: 10;
}

button {
    position: absolute;
    bottom: 0;
    width: 100%;
    padding: 20px;
    font-size: 18px;
    border: none;
    background: #ff6f00;
    color: white;
    z-index: 10;
}

#compass {
    position: absolute;
    top: 20px;
    left: 20px;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: rgba(255,255,255,0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    z-index: 10;
}

#miniMap {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 120px;
    height: 120px;
    background: rgba(0,0,0,0.4);
    border-radius: 10px;
    z-index: 10;
}
</style>
</head>
<body>

<div id="compass">N</div>
<canvas id="miniMap" width="120" height="120"></canvas>
<div id="status">Toque na tela para iniciar GPS</div>
<button id="finishBtn">Finalizar Caminhada</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>

// ---------------- SCENE ----------------
const scene = new THREE.Scene()
scene.background = new THREE.Color(0x87ceeb)

const camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth/window.innerHeight,
    0.1,
    10000
)

camera.position.set(0,40,40)

const renderer = new THREE.WebGLRenderer({ antialias:true })
renderer.setSize(window.innerWidth, window.innerHeight)
document.body.appendChild(renderer.domElement)

window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight
    camera.updateProjectionMatrix()
    renderer.setSize(window.innerWidth, window.innerHeight)
})

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1))

// ---------------- PLAYER ----------------
const player = new THREE.Mesh(
    new THREE.SphereGeometry(2,16,16),
    new THREE.MeshStandardMaterial({ color:0xff0000 })
)
player.position.y = 2
scene.add(player)

// ---------------- TRAIL ----------------
const trailPoints = []
const trailGeometry = new THREE.BufferGeometry()
const trailMaterial = new THREE.LineBasicMaterial({ color:0xffaa00 })
const trailLine = new THREE.Line(trailGeometry, trailMaterial)
scene.add(trailLine)

// ---------------- CHUNKS ----------------
const chunkSize = 100
const chunks = {}

function generateChunk(cx, cz){
    const key = cx+"_"+cz
    if(chunks[key]) return

    const group = new THREE.Group()

    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(chunkSize,chunkSize),
        new THREE.MeshStandardMaterial({ color:0x2e7d32 })
    )

    ground.rotation.x = -Math.PI/2
    ground.position.set(
        cx*chunkSize+chunkSize/2,
        0,
        cz*chunkSize+chunkSize/2
    )

    group.add(ground)

    for(let i=0;i<6;i++){
        const tree = new THREE.Mesh(
            new THREE.ConeGeometry(3,8,8),
            new THREE.MeshStandardMaterial({ color:0x1b5e20 })
        )
        tree.position.set(
            ground.position.x+(Math.random()-0.5)*chunkSize,
            4,
            ground.position.z+(Math.random()-0.5)*chunkSize
        )
        group.add(tree)
    }

    scene.add(group)
    chunks[key]=group
}

function checkChunks(){
    const cx=Math.floor(player.position.x/chunkSize)
    const cz=Math.floor(player.position.z/chunkSize)

    for(let x=-1;x<=1;x++){
        for(let z=-1;z<=1;z++){
            generateChunk(cx+x,cz+z)
        }
    }
}

// ---------------- CAMERA ----------------
let cameraTarget = new THREE.Vector3()
let zoom = 40
let cameraMode = "follow"
let isDragging=false
let prevTouch

function updateCamera(){
    if(cameraMode==="follow"){
        cameraTarget.copy(player.position)
    }

    const desired = new THREE.Vector3(
        cameraTarget.x,
        zoom,
        cameraTarget.z+zoom
    )

    camera.position.lerp(desired,0.1)
    camera.lookAt(cameraTarget)
}

renderer.domElement.addEventListener("touchstart",e=>{
    isDragging=true
    prevTouch=e.touches[0]
    cameraMode="free"
})

renderer.domElement.addEventListener("touchmove",e=>{
    if(!isDragging)return
    const t=e.touches[0]
    const dx=t.clientX-prevTouch.clientX
    const dy=t.clientY-prevTouch.clientY

    cameraTarget.x-=dx*0.5
    cameraTarget.z+=dy*0.5

    prevTouch=t
})

renderer.domElement.addEventListener("touchend",()=>{
    isDragging=false
})

renderer.domElement.addEventListener("wheel",e=>{
    zoom+=e.deltaY*0.1
    if(zoom<5)zoom=5
})

// ---------------- GPS ----------------
let originLat=null
let originLon=null
const scale=10000
let gpsStarted=false

function startGPS(){

    if(gpsStarted) return
    gpsStarted=true

    document.getElementById("status").innerText="Conectando GPS..."

    navigator.geolocation.watchPosition(pos=>{

        document.getElementById("status").innerText="GPS conectado"

        if(originLat===null){
            originLat=pos.coords.latitude
            originLon=pos.coords.longitude
        }

        const dx=(pos.coords.longitude-originLon)*scale
        const dz=(pos.coords.latitude-originLat)*scale

        player.position.x=dx
        player.position.z=dz

        trailPoints.push(new THREE.Vector3(dx,2,dz))
        trailGeometry.setFromPoints(trailPoints)

        checkChunks()

    },err=>{
        document.getElementById("status").innerText="Erro GPS"
        console.log(err)
    },{
        enableHighAccuracy:true
    })
}

document.body.addEventListener("click",startGPS,{once:true})

// ---------------- COMPASS ----------------
window.addEventListener("deviceorientation",e=>{
    if(e.alpha!==null){
        document.getElementById("compass").style.transform=
            "rotate("+(-e.alpha)+"deg)"
    }
})

// ---------------- MINI MAP ----------------
const miniCanvas=document.getElementById("miniMap")
const miniCtx=miniCanvas.getContext("2d")

function drawMiniMap(){
    miniCtx.clearRect(0,0,120,120)
    miniCtx.fillStyle="green"
    miniCtx.fillRect(0,0,120,120)

    miniCtx.fillStyle="orange"
    trailPoints.forEach(p=>{
        miniCtx.fillRect(
            60+p.x*0.02,
            60+p.z*0.02,
            2,2
        )
    })

    miniCtx.fillStyle="red"
    miniCtx.fillRect(60,60,4,4)
}

// ---------------- SCREENSHOT ----------------
document.getElementById("finishBtn").addEventListener("click",()=>{
    const dataURL=renderer.domElement.toDataURL("image/png")
    const link=document.createElement("a")
    link.href=dataURL
    link.download="pathmesh.png"
    link.click()
})

// ---------------- LOOP ----------------
function animate(){
    requestAnimationFrame(animate)
    updateCamera()
    drawMiniMap()
    renderer.render(scene,camera)
}

animate()

</script>
</body>
</html>